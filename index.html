// ====================================================================
// โค้ดสำหรับ Code.gs: API Backend ฉบับสมบูรณ์ (V3: Pool Settlement Logic)
// ====================================================================

const SHEET_NAME = {
    CONFIG: 'Config',
    TRANSACTIONS: 'Transactions',
    ESTIMATES: 'Estimates',
    LOGS: 'Logs',
    ACTIVE_USERS: 'ActiveUsers', 
    VISITORS: 'Visitors',
    MEMBERS: 'Members', 
    ADVANCE: 'Advance' 
};

// ====================================================================
// CORE FUNCTIONS: doGet
// ====================================================================

function doGet(e) {
    let result = {};
    const ss = SpreadsheetApp.getActiveSpreadsheet(); 

    // Return HTML content if no action parameter is provided
    if (!e || !e.parameter || !e.parameter.action) {
        return HtmlService.createTemplateFromFile('index').evaluate()
            .setTitle(ss.getName())
            .setSandboxMode(HtmlService.SandboxMode.IFRAME);
    }
    
    try {
        if (!ss) {
             result = { success: false, message: 'CRITICAL ERROR: Spreadsheet not bound.' };
        } else {
            const params = e.parameter; 
            const action = params.action;
            
            // Convert amount to number if present
            const processedParams = {
                action: action,
                passcode: params.passcode,
                user: params.user,
                type: params.type,
                amount: params.amount ? parseFloat(params.amount) : undefined,
                description: params.description,
                rowIndex: params.rowIndex ? parseInt(params.rowIndex) : undefined,
                paymentType: params.paymentType,
                paidBy: params.paidBy,
                member: params.member
            };

            const user = processedParams.user;
            
            // Handle actions that don't require login/user check first
            if (action === 'LOGIN') {
                result = login(user, processedParams.passcode);
            } else {
                // All other actions require a logged-in user
                if (!user) {
                    result = { success: false, message: 'Authentication required.' };
                } else {
                    switch (action) {
                        case 'GET_DATA':
                            // The core function to retrieve all necessary data
                            const transactionData = getSheetDataWithHeader(ss, SHEET_NAME.TRANSACTIONS);
                            const estimateData = getSheetDataWithHeader(ss, SHEET_NAME.ESTIMATES);
                            const advanceData = getSheetDataWithHeader(ss, SHEET_NAME.ADVANCE);
                            const poolConfig = getConfigSettings(ss);
                            
                            const members = getSheetDataWithHeader(ss, SHEET_NAME.MEMBERS).map(row => row.MemberName);

                            // V3: Get Settlement Data (Includes Pool Balance)
                            const settlementResult = getSettlementData(ss);
                            
                            if (settlementResult.success) {
                                result = {
                                    success: true,
                                    transactions: transactionData,
                                    estimates: estimateData,
                                    advance: advanceData,
                                    poolBalance: settlementResult.poolNetBalance, // Pool Net Balance (Real money)
                                    availableBalance: settlementResult.availableBalance, // Pool Balance - Total Estimate (Useable money)
                                    settlement: settlementResult.settlementData, // V3 settlement data
                                    members: members,
                                    message: 'Data loaded successfully.'
                                };
                            } else {
                                result = settlementResult;
                            }
                            break;

                        case 'ADD_TRANSACTION':
                            result = handleModification(ss, processedParams, 'ADD_TRANSACTION');
                            break;
                        case 'ADD_ESTIMATE':
                            result = handleModification(ss, processedParams, 'ADD_ESTIMATE');
                            break;
                        case 'DELETE_TRANSACTION':
                            result = handleModification(ss, processedParams, 'DELETE_TRANSACTION');
                            break;
                        case 'DELETE_ESTIMATE':
                            result = handleModification(ss, processedParams, 'DELETE_ESTIMATE');
                            break;
                        case 'FORWARD_ESTIMATE':
                            result = handleModification(ss, processedParams, 'FORWARD_ESTIMATE');
                            break;
                        case 'ADD_MEMBER':
                            result = handleModification(ss, processedParams, 'ADD_MEMBER');
                            break;
                        case 'ADD_ADVANCE':
                            result = handleModification(ss, processedParams, 'ADD_ADVANCE');
                            break;
                        case 'CLEAR_ACTIVE_USERS':
                            result = clearActiveUsers(ss, processedParams.user);
                            break;
                        default:
                            result = { success: false, message: `Unknown action: ${action}` };
                            break;
                    }
                }
            }
        }
    } catch (error) {
        Logger.log(error);
        result = { success: false, message: `Server error: ${error.message}` };
    }

    // Return JSON response for API calls
    return ContentService.createTextOutput(JSON.stringify(result))
        .setMimeType(ContentService.MimeType.JSON);
}


// ====================================================================
// CORE: LOGIN FUNCTION (Updated to use Input Text)
// ====================================================================

/**
 * Handles user login by checking against Member list and Admin config.
 * Regular members don't need a passcode. Admin needs a passcode.
 * @param {string} user The user name entered.
 * @param {string} passcode The passcode entered.
 * @returns {object} { success: boolean, message: string }
 */
function login(user, passcode) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    if (!user) {
        return { success: false, message: 'กรุณากรอกชื่อผู้ใช้งาน' };
    }

    const members = getSheetDataWithHeader(ss, SHEET_NAME.MEMBERS).map(row => row.MemberName);
    const config = getConfigSettings(ss);
    const adminUser = config.AdminUser;
    const adminPasscode = config.AdminPasscode;

    // Check if the user is a regular member (case-insensitive)
    const isMember = members.some(m => m.toLowerCase() === user.toLowerCase());

    if (isMember) {
        // Regular members can log in without a passcode check
        logAction(ss, user, `LOGIN (Member)`);
        return { success: true, message: 'เข้าสู่ระบบสำเร็จในฐานะสมาชิก' };
    }

    // Check if the user is the Admin (case-insensitive)
    if (adminUser && user.toLowerCase() === adminUser.toLowerCase()) {
        // Check Admin Passcode
        if (passcode === adminPasscode) {
            logAction(ss, user, `LOGIN (Admin)`);
            return { success: true, message: 'เข้าสู่ระบบสำเร็จในฐานะผู้ดูแล' };
        } else {
            return { success: false, message: 'รหัสผ่านผู้ดูแลไม่ถูกต้อง' };
        }
    }

    // If neither a member nor the admin
    return { success: false, message: `ไม่พบชื่อผู้ใช้งาน "${user}" ในรายชื่อสมาชิก/ผู้ดูแล` };
}

// ====================================================================
// CORE: SETTLEMENT LOGIC (V3 - Finalized for Credit/Debit)
// ====================================================================

/**
 * Calculates the V3 settlement data including Pool Net Balance and Available Balance.
 * @param {GoogleAppsScript.Spreadsheet.Spreadsheet} ss The active spreadsheet.
 * @returns {object} { success: boolean, settlementData: array, poolNetBalance: number, availableBalance: number, ... }
 */
function getSettlementData(ss) {
    const transactionData = getSheetDataWithHeader(ss, SHEET_NAME.TRANSACTIONS);
    const advanceData = getSheetDataWithHeader(ss, SHEET_NAME.ADVANCE);
    const estimateData = getSheetDataWithHeader(ss, SHEET_NAME.ESTIMATES);
    const memberNames = getSheetDataWithHeader(ss, SHEET_NAME.MEMBERS).map(row => row.MemberName);
    const config = getConfigSettings(ss);
    const numMembers = memberNames.length;

    // 1. Initialize Settlement Data
    const memberSettlement = memberNames.reduce((acc, name) => {
        acc[name] = {
            member: name,
            paidOut: 0,         // Total money this person paid out (Credit to them)
            incomeIn: 0,        // Total money this person put into the Pool (NOT credit, but reduces pool debt)
            expensePool: 0,     // Total expense paid from the Pool
            expenseIndividual: 0,// Total expense paid by individuals (will be split)
            shareDebt: 0,       // Total debt/share from expenses (will be calculated)
            advanceDebt: 0,     // Total Advance money this person took
            netBalance: 0,      // Final Credit/Debt
            baseDebit: 0        // Share of expense debt for display
        };
        return acc;
    }, {});

    let poolNetBalance = config.StartBalance || 0;
    let totalEstimate = 0;
    let totalSharedExpense = 0; // Total expense to be shared among members

    // 2. Process Transactions (Pool Balance, PaidOut, IncomeIn, TotalSharedExpense)
    transactionData.forEach(t => {
        const amount = t.Amount;
        const paidBy = t['Paid By'];
        const member = t.Member; // For Income transactions

        if (t.Type === 'INCOME') {
            poolNetBalance += amount;
            // Record who paid in (if applicable, otherwise it's Sponsor)
            if (member && memberSettlement[member]) {
                memberSettlement[member].incomeIn += amount; 
            }
        } else if (t.Type === 'EXPENSE') {
            if (t['Payment Type'] === 'POOL') {
                poolNetBalance -= amount;
                memberSettlement[paidBy].expensePool += amount; // Track for reporting
            } else if (t['Payment Type'] === 'INDIVIDUAL') {
                memberSettlement[paidBy].paidOut += amount;
                memberSettlement[paidBy].expenseIndividual += amount; // Track for reporting
                totalSharedExpense += amount; // Add to total to be shared
            }
        }
    });

    // 3. Process Estimates (Calculate Total Estimate)
    estimateData.forEach(e => {
        totalEstimate += e.Amount;
    });

    // 4. Process Advances (Advance Debt)
    advanceData.forEach(a => {
        if (memberSettlement[a.Member]) {
            memberSettlement[a.Member].advanceDebt += a.Amount;
        }
    });

    // 5. Calculate Expense Share (The core V3 calculation)
    
    // a) Calculate total Individual Expenses to be shared
    // This is already 'totalSharedExpense'
    
    // b) Calculate the share amount per member
    const expenseSharePerMember = numMembers > 0 ? totalSharedExpense / numMembers : 0;

    // c) Calculate Net Balance for each member
    Object.keys(memberSettlement).forEach(name => {
        const s = memberSettlement[name];
        
        // Expense Share Debt (What they owe for shared expenses)
        s.shareDebt = expenseSharePerMember;
        
        // Final Net Expense Share (What they truly owe after factoring in their income/contributions/paid-outs)
        // **V3 Logic:** Net expense share is fixed per person, but we must factor in their Income to Pool.
        // We use the simpler Credit - Debt model:
        
        // CREDIT: Money paid out by the individual (INDIVIDUAL expense type)
        // DEBIT: Expense share they must cover
        // DEBIT: Advance debt they owe
        
        // This is the true expense they must cover *from their own pocket*
        const finalNetExpenseShare = expenseSharePerMember; 
        
        // Final Net Balance: (Credit - Debt)
        // (เงินที่จ่ายออกไปก่อน) - (ยอดที่ต้องรับผิดชอบส่วนกลาง) - (ยอด Advance ที่เบิกไป)
        s.netBalance = s.paidOut - finalNetExpenseShare - s.advanceDebt; 
        
        // For display in the Debit column on the frontend
        s.baseDebit = finalNetExpenseShare; 
    });

    return {
        success: true,
        settlementData: Object.values(memberSettlement),
        members: memberNames,
        poolNetBalance: poolNetBalance, // ยอดคงเหลือจริงในกองกลาง
        availableBalance: poolNetBalance - totalEstimate // ยอดคงเหลือที่ใช้ได้
    };
}

// ====================================================================
// HELPER FUNCTIONS: (Modification, Data Retrieval, Logging)
// ====================================================================

/**
 * A centralized function to handle all modifications (Add/Delete/Forward).
 * @param {GoogleAppsScript.Spreadsheet.Spreadsheet} ss The active spreadsheet.
 * @param {object} params The processed parameters from doGet.
 * @param {string} action The action type (e.g., 'ADD_TRANSACTION').
 * @returns {object} { success: boolean, message: string }
 */
function handleModification(ss, params, action) {
    let sheet;
    let dataRow;

    try {
        switch (action) {
            case 'ADD_TRANSACTION':
                sheet = ss.getSheetByName(SHEET_NAME.TRANSACTIONS);
                if (!sheet) throw new Error(`Sheet ${SHEET_NAME.TRANSACTIONS} not found.`);

                if (!params.amount || !params.description || !params.type) {
                    throw new Error('Transaction details are incomplete.');
                }
                
                // Get Payment Type (Pool/Individual) for Expense, and Member for Income
                let paymentType = '';
                let paidBy = '';
                let member = '';

                if (params.type === 'EXPENSE') {
                    paymentType = params.paymentType;
                    paidBy = params.paidBy;
                    if (!paidBy) throw new Error('Expense: ต้องระบุผู้จ่ายเงิน');
                } else if (params.type === 'INCOME') {
                    // Only record if member is explicitly selected, otherwise it's sponsor
                    member = params.member || 'SPONSOR'; 
                    paidBy = ''; // N/A for income
                    paymentType = 'POOL';
                }

                // [Timestamp, Type, Amount, Description, Paid By, Payment Type, Member, Logged By]
                dataRow = [
                    new Date(), 
                    params.type, 
                    params.amount, 
                    params.description, 
                    paidBy, 
                    paymentType, 
                    member,
                    params.user
                ];
                sheet.appendRow(dataRow);
                logAction(ss, params.user, `${action}: ${params.type} ${params.amount}`);
                return { success: true, message: 'บันทึกรายการสำเร็จ' };

            case 'ADD_ESTIMATE':
                sheet = ss.getSheetByName(SHEET_NAME.ESTIMATES);
                if (!sheet) throw new Error(`Sheet ${SHEET_NAME.ESTIMATES} not found.`);

                if (!params.amount || !params.description) {
                    throw new Error('Estimate details are incomplete.');
                }

                // [Timestamp, Amount, Description, Logged By]
                dataRow = [
                    new Date(), 
                    params.amount, 
                    params.description, 
                    params.user
                ];
                sheet.appendRow(dataRow);
                logAction(ss, params.user, `${action}: ${params.amount}`);
                return { success: true, message: 'บันทึกรายการประเมินสำเร็จ' };
            
            case 'ADD_MEMBER':
                sheet = ss.getSheetByName(SHEET_NAME.MEMBERS);
                if (!sheet) throw new Error(`Sheet ${SHEET_NAME.MEMBERS} not found.`);

                if (!params.description) { // description holds the new member name
                    throw new Error('กรุณาระบุชื่อสมาชิก');
                }
                
                const existingMembers = getSheetDataWithHeader(ss, SHEET_NAME.MEMBERS).map(row => row.MemberName.toLowerCase());
                const newMemberName = params.description.trim();

                if (existingMembers.includes(newMemberName.toLowerCase())) {
                    throw new Error(`ชื่อสมาชิก "${newMemberName}" มีอยู่แล้ว`);
                }

                sheet.appendRow([newMemberName, new Date(), params.user]);
                logAction(ss, params.user, `${action}: ${newMemberName}`);
                return { success: true, message: `เพิ่มสมาชิก "${newMemberName}" สำเร็จ` };
                
            case 'ADD_ADVANCE':
                sheet = ss.getSheetByName(SHEET_NAME.ADVANCE);
                if (!sheet) throw new Error(`Sheet ${SHEET_NAME.ADVANCE} not found.`);

                if (!params.amount || !params.member) {
                    throw new Error('กรุณาระบุสมาชิกและจำนวนเงิน');
                }
                
                // [Timestamp, Member, Amount, Logged By]
                dataRow = [
                    new Date(), 
                    params.member, 
                    params.amount, 
                    params.user
                ];
                sheet.appendRow(dataRow);
                logAction(ss, params.user, `${action}: ${params.member} ${params.amount}`);
                return { success: true, message: 'บันทึกการเบิกเงินล่วงหน้าสำเร็จ' };
                
            case 'DELETE_TRANSACTION':
            case 'DELETE_ESTIMATE':
                const isTransaction = action === 'DELETE_TRANSACTION';
                sheet = ss.getSheetByName(isTransaction ? SHEET_NAME.TRANSACTIONS : SHEET_NAME.ESTIMATES);
                if (!sheet) throw new Error(`Sheet ${sheetName} not found.`);
                
                // rowIndex from client is 0-based for data array, so 1-based for sheet row (plus header row)
                const sheetRow = params.rowIndex + 2; 

                if (sheetRow > sheet.getLastRow() || sheetRow <= 1) {
                    throw new Error('Row index is out of bounds.');
                }
                
                // Optional: Get data before deletion for better logging
                const deletedData = sheet.getRange(sheetRow, 1, 1, sheet.getLastColumn()).getValues()[0].join(', ');

                sheet.deleteRow(sheetRow);
                logAction(ss, params.user, `${action} (Row ${params.rowIndex + 1}): ${deletedData}`);
                return { success: true, message: `ลบรายการสำเร็จ (แถวที่ ${params.rowIndex + 1})` };
            
            case 'FORWARD_ESTIMATE':
                const estimateSheet = ss.getSheetByName(SHEET_NAME.ESTIMATES);
                const transactionSheet = ss.getSheetByName(SHEET_NAME.TRANSACTIONS);
                if (!estimateSheet || !transactionSheet) {
                    throw new Error('Estimate or Transaction sheet not found.');
                }

                // rowIndex from client is 0-based for data array, so 1-based for sheet row (plus header row)
                const estimateSheetRow = params.rowIndex + 2; 

                if (estimateSheetRow > estimateSheet.getLastRow() || estimateSheetRow <= 1) {
                    throw new Error('Estimate row index is out of bounds.');
                }
                
                // 1. Get Estimate Data
                const estimateRange = estimateSheet.getRange(estimateSheetRow, 1, 1, estimateSheet.getLastColumn());
                const estimateValues = estimateRange.getValues()[0];
                const estimateAmount = estimateValues[1]; // Amount is at index 1
                const estimateDescription = estimateValues[2]; // Description is at index 2

                // 2. Create Transaction Data Row
                // [Timestamp, Type, Amount, Description, Paid By, Payment Type, Member, Logged By]
                const transactionRow = [
                    new Date(), 
                    'EXPENSE', // Always expense when forwarding estimate
                    estimateAmount, 
                    `[จาก Estimate] ${estimateDescription}`, 
                    params.user, // Assume the person forwarding is the one who paid out (Credit)
                    'INDIVIDUAL', // Assume it's paid out personally (Credit/Shared)
                    '',
                    params.user
                ];
                
                // 3. Append to Transactions
                transactionSheet.appendRow(transactionRow);

                // 4. Delete from Estimates
                estimateSheet.deleteRow(estimateSheetRow);

                logAction(ss, params.user, `FORWARD_ESTIMATE (Row ${params.rowIndex + 1}): ${estimateAmount} - ${estimateDescription}`);
                return { success: true, message: 'บันทึกเป็นรายจ่ายจริงสำเร็จ' };

            default:
                throw new Error(`Invalid action: ${action}`);
        }
    } catch (error) {
        Logger.log(`Modification Error (${action}): ${error.message}`);
        return { success: false, message: `ดำเนินการล้มเหลว: ${error.message}` };
    }
}


/**
 * Retrieves sheet data with the first row as headers.
 * @param {GoogleAppsScript.Spreadsheet.Spreadsheet} ss The active spreadsheet.
 * @param {string} sheetName The name of the sheet.
 * @returns {Array<Object>} An array of objects where keys are column headers.
 */
function getSheetDataWithHeader(ss, sheetName) {
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet || sheet.getLastRow() < 1) return [];

    const range = sheet.getDataRange();
    const values = range.getValues();
    
    if (values.length < 2) return []; // Only header row

    const headers = values[0];
    const data = values.slice(1);

    return data.map(row => {
        const obj = {};
        headers.forEach((header, i) => {
            obj[header] = row[i];
        });
        return obj;
    });
}

/**
 * Retrieves configuration settings from the Config sheet.
 * @param {GoogleAppsScript.Spreadsheet.Spreadsheet} ss The active spreadsheet.
 * @returns {object} An object containing all config key-value pairs.
 */
function getConfigSettings(ss) {
    const sheet = ss.getSheetByName(SHEET_NAME.CONFIG);
    if (!sheet || sheet.getLastRow() < 2) {
        return {
            StartBalance: 0,
            AdminUser: 'Admin',
            AdminPasscode: '0000'
        }; // Default values
    }

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 2).getValues();
    const config = {};
    
    data.forEach(row => {
        const key = row[0];
        let value = row[1];
        
        // Convert number-like values
        if (!isNaN(value) && value !== '') {
            value = parseFloat(value);
        }

        config[key] = value;
    });

    return config;
}

/**
 * Clears the list of active/logged-in users (used for emergency logout/lockout).
 * @param {GoogleAppsScript.Spreadsheet.Spreadsheet} ss The active spreadsheet.
 * @param {string} user The user who executed the action (for logging).
 * @returns {object} { success: boolean, message: string }
 */
function clearActiveUsers(ss, user) {
    const sheet = ss.getSheetByName(SHEET_NAME.ACTIVE_USERS);
    if (!sheet) {
         return { success: false, message: 'Sheet ActiveUsers not found.' };
    }
    
    // Clear all rows except the header
    sheet.getRange(2, 1, sheet.getLastRow(), sheet.getLastColumn()).clearContent();
    
    logAction(ss, user, 'CLEAR_ACTIVE_USERS');
    return { success: true, message: 'เคลียร์ผู้ใช้งานค้างทั้งหมดสำเร็จ' };
}


/**
 * Logs an action to the Logs sheet.
 * @param {GoogleAppsScript.Spreadsheet.Spreadsheet} ss The active spreadsheet.
 * @param {string} user The user who performed the action.
 * @param {string} action The description of the action.
 */
function logAction(ss, user, action) {
    const sheet = ss.getSheetByName(SHEET_NAME.LOGS);
    if (!sheet) return; 

    const timestamp = new Date().toLocaleString('th-TH', { 
        year: 'numeric', month: '2-digit', day: '2-digit', 
        hour: '2-digit', minute: '2-digit', second: '2-digit', 
        hour12: false 
    });
    
    sheet.appendRow([timestamp, user, action]);
}
